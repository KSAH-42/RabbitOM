public abstract class RtspTransportOptions
{
	public abstract int Type {get; }
}

public class RtspReceiverOptions
{
}

public class RtspUdpReceiverOptions : RtspReceiverOptions
{
    public string Address { get; }
    public int Port {get; }
}

public class RtspMulticastReceiverOptions : RtspReceiverOptions
{
    public string Address { get; }
    public int Port { get; }
    public byte TTL { get; }
}

public sealed class RtspReceiverConfiguration
{
    public bool AutoStartStreaming { get; set; }
    public string Uri { get; set; }
    public string UserName { get; set; }
    public string Password { get; set; }
    public TimeSpan ReceiveTimeout { get; set; }
    public TimeSpan SendTimeout { get; set; }
    public TimeSpan RetryInterval { get; set; }
    public TimeSpan RetryDelay { get; set; }
    public Guid MediaFormat { get; set; }
    public int KeepAliveMode { get; set; }
    public RtspReceiverOptions TransportOptions {get; set; }
}

public abstract class RtspReceiverConfigurer
{
    public abstract void Configure();
}

public abstract class RtspClient : IDisposable
{
    public event EventHandler CommunicationStarted;
    public event EventHandler CommunicationStopped;
    public event EventHandler Connected;
    public event EventHandler Disconnected;
    public event EventHandler StreamingStarted;
    public event EventHandler StreamingStopped;
    public event EventHandler DataReceived;
    public event EventHandler Error;

    public abstract object SyncRoot {get; }
    public abstract bool IsCommunicationStarted {get; }
    public abstract bool IsConnected { get; }
    public abstract bool IsReceivingData { get; }
    public abstract bool IsStreamingStarted { get; }
    public abstract bool IsDisposed { get; }
    public abstract RtspReceiverConfiguration Configuration { get; }
    public abstract RTSPHeaderCollection OptionsHeaders { get; }
    public abstract RTSPHeaderCollection DescribeHeaders { get; }
    public abstract RTSPHeaderCollection SetupHeaders { get;}
    public abstract RTSPHeaderCollection PlayHeaders { get; }
    public abstract RTSPHeaderCollection TearDownHeaders { get;}

    public abstract bool StartCommunication();
    public abstract void StopCommunication();
    public abstract void Shutdown();
    public abstract bool Shutdown(TimeSpan timeout);
    public abstract bool WaitConnectionSucceed();
    public abstract bool StartStreaming();
    public abstract void StopStreaming();
    public abstract void Dispatch(Action action );
    public abstract void Dispose();

    protected void RaiseEvent( EventArgs e){}

    protected virtual void OnCommunicationStarted(EventArgs e ) { }
    protected virtual void OnCommunicationStopped(EventArgs e) { }
    protected virtual void OnConnected(EventArgs e) { }
    protected virtual void OnDisconnected(EventArgs e) { }
    protected virtual void OnStreamingStarted(EventArgs e) { }
    protected virtual void OnStreamingStopped(EventArgs e) { }
    protected virtual void OnConnectionError(EventArgs e) { }
    protected virtual void OnAuthenticationError(EventArgs e) { }
    protected virtual void OnProtocolError(EventArgs e) { }
    protected virtual void OnTransportError(EventArgs e) { }
}

public class RtspMediaReceiver : RtspReceiver
{
    private readonly RtspMediaSession _session;

    public RtspMediaReceiver()
    {
        _session = new RtspMediaSession( this );
    }

	public override object SyncRoot 
        => _session.SyncRoot;

	public override bool IsCommunicationStarted 
        => _session.IsCommunicationStarted ;
    
    public override bool IsConnected 
        => _session.IsConnected;

    public override bool IsReceivingData 
        => _session.IsReceivingData;

    public override bool IsStreamingStarted 
        => _session.IsStreamingStarted;

    public override bool IsDisposed 
        => _session.IsDisposed;

    public override RtspReceiverConfiguration Configuration 
        => _session.Configuration;

    public override RTSPHeaderCollection OptionsHeaders 
        => _session.OptionsHeaders;

    public override RTSPHeaderCollection DescribeHeaders
        => _session.DescribeHeaders;

    public override RTSPHeaderCollection SetupHeaders 
        => _session.SetupHeaders;

    public override RTSPHeaderCollection PlayHeaders 
        => _session.PlayHeaders;

    public override RTSPHeaderCollection TearDownHeaders 
        => _session.TearDownHeaders;

    public override void Dispatch(Action action)
	{
        _session.Dispatch( action );
	}

	public override void Dispose()
	{
        _session.Dispose();
	}

	public override void Shutdown()
	{
        _session.Shutdown();
	}

	public override bool Shutdown(TimeSpan timeout)
	{
        return _session.Shutdown( timeout );
    }

	public override bool StartCommunication()
	{
		return _session.StartCommunication();
	}

	public override bool StartStreaming()
	{
        return _session.StartStreaming();
    }

	public override void StopCommunication()
	{
        _session.StopCommunication()
	}

	public override void StopStreaming()
	{
        _session.StopStreaming()
	}

	public override bool WaitConnectionSucceed()
	{
        return _session.WaitConnectionSucceed();
    }
}























































// appear on the base class
client.Configuration.Uri
client.Configuration.RetryTimeout
client.Configuration.ReceiveTimeout
client.Configuration.SendTimeout
client.Configuration.UserName
client.Configuration.Password

client.Options.MulticastAddress // appear on multicast client
client.Options.MutlicatPort // appear on multicast client
client.Options.Ttl // appear on multicast client

client.Configure( Configuration configuration ); // appear on the base class
client.Configure( Options options ); // appear on multicast client

client.StartCommunication();
client.StopCommunication()

client.IsCommunicationStarted
client.IsConnected
client.IsReceivingPackets
client.IsStreamingStarted

client.StartStreaming()
client.StartStreamingAync()
client.StopStreaming()
client.StopStreamingAsync()

client.CommunicationStarterd += (sender,e) =>
{
    client.StartStreaming();
};

or :

client.Dispatch( () => client.StartStreaming() );

problems: a developper can write this code which are a none sense but possible

client.ProtocolError += (sender,e) =>
{
    client.StartStreaming();
};

do we need to change the class name by using ReceiverClass and remove the StartStreaming methods ? 
 => there is a high probability to say yes.
 => so, todo: make a choice this week and we close the implemtation and start the cli project.
 



About deep namespace and flat namespace 
  => stay on flatten namespace like the Data Dog sdk. it is better.


public class Dispatcher
{
    public bool IsRunning {get;}

    public void Run(){}
    public void Terminate(){}

    public void Dispatch( Action action ) {}
}

public abstract class RTSPSession : IDisposable
{
        public event EventHandler<RTSPCommunicationStartedEventArgs> CommunicationStarted;
        public event EventHandler<RTSPCommunicationStoppedEventArgs> CommunicationStopped;
        public event EventHandler<RTSPConnectedEventArgs> Connected;
        public event EventHandler<RTSPDisconnectedEventArgs> Disconnected;
        public event EventHandler<RTSPPacketReceivedEventArgs> PacketReceived;
        public event EventHandler<RTSPStreamingStartedEventArgs> StreamingStarted;
        public event EventHandler<RTSPStreamingStoppedEventArgs> StreamingStopped;
        public event EventHandler<RTSPConnectionErrorEventArgs> ConnectionError;
        public event EventHandler<RTSPAuthenticationErrorEventArgs> AuthenticationError;
        public event EventHandler<RTSPProtocolErrorEventArgs> ProtocolError;

        public abstract Configuration Configuration {get;}

        public abstract bool IsDisposed {get;}
        public abstract bool IsOpened {get;}
        public abstract bool IsClosed {get;}

        // these functions can be reused on the childs classes
        // and to avoid duplicated codes and solve the issue
        // that i don't want to have a wrapper around this class
        // We should reduce the number of classes

        // See after this class 

        protected readonly RTSPConnection _connection = new RTSPConnection();

        public static void StartEventLoop( Session session );
        public static void StopEventLoop( Session session );
        public static void DoEvents( Session session );
        public static void WaitForEvents( Session session );

        public abstract void Open();
        public abstract void Close();
        public abstract void Dispose();
        public abstract void Ping();
        public abstract bool StartStreaming();
        public abstract bool StopStreaming();
        public abstract bool WaitConnectionSucceed(Timeout timespan);

        public abstract TConfiguration GetConfiguration<TConfiguration>();
        public abstract void SetConfiguration<TConfiguration>( TConfiguration configuration );
        public abstract void Dispatch( Action action );
        public abstract void TriggerEvent( EventArgs action );
        

        protected virtual void OnCommunicationStarted( RTSPCommunicationStartedEventArgs e )
        {
            CommunicationStarted?.TryInvoke( this , e );
        }

        protected virtual void OnCommunicationStopped( RTSPCommunicationStoppedEventArgs e )
        {
            CommunicationStopped?.TryInvoke( this , e );
        }

        protected virtual void OnConnected( RTSPConnectedEventArgs e )
        {
            Connected?.TryInvoke( this ,e );
        }

        protected virtual void OnDisconnected( RTSPDisconnectedEventArgs e )
        {
            Disconnected?.TryInvoke( this , e );
        }

        protected virtual void OnPacketReceived( RTSPPacketReceivedEventArgs e )
        {
            PacketReceived?.TryInvoke( this , e );
        }

        protected virtual void OnStreamingStarted(RTSPStreamingStartedEventArgs e)
        {
            StreamingStarted?.TryInvoke(this, e);
        }

        protected virtual void OnStreamingStopped(RTSPStreamingStoppedEventArgs e)
        {
            StreamingStopped?.TryInvoke(this, e);
        }

        protected virtual void OnConnectionError(RTSPConnectionErrorEventArgs e)
        {
            ConnectionError?.TryInvoke(this, e);
        }

        protected virtual void OnAuthenticationError( RTSPAuthenticationErrorEventArgs e )
        {
            AuthenticationError?.TryInvoke( this , e );
        }

        protected virtual void OnProtocolError(RTSPProtocolErrorEventArgs e)
        {
            ProtocolError?.TryInvoke(this, e);
        }
}



/////////////////////////////////////////////////////////////////////////////////////////






    Simplify the dispatcher mecanism, or find something to avoid potential timeout on callbacks/event handler subscribptions
especially if we are using udp protocol, datagram can be lost if a timeout occurs after receiving packets.

The actual dispatch, could be nice, to track every things. and all reliable recorders use ring buffer. It's a basic thing.

RabbitOM.Net.Alpha
RabbitOM.Net.Alpha.Transports 
{
    add sockets extensions class here
    add transport layer for receiving data. Find a good name for this class.
      => the problem is that a receiver classes must used a thread and so namespace must be changed...
        And some one are thinking about the same thing : https://www.codeproject.com/Articles/884583/Advanced-TCP-Socket-Programming-with-NET
        AFAIK transport layer class should be not a simple abstract socket wrapper 
         => is must expose send/receive using message objects not buffer !
         => and serialization is handled by this kind of class
        so i must find a different name!!! and i don't want to introduce rtp packet in this namespace level.
        otherwise remove transports namespace and expose it on the camera device implementation that expose rtp packet, and i don't think that is a good to expose frame or rtp packet for recorder implementation due for performance reasons. for render usercontrols, it's correct, not for a recorder application. 
}

Todo => Change the current architecture

and move to this one:
Check if we can move to a namespace like this:

Rabbit.Streaming.Server.exe
{
    Rabbit.Streaming.dll
    Rabbit.Streaming.Engine.dll
    Rabbit.Streaming.Devices.dll
    Rabbit.Streaming.Devices.Cameras.dll
    etc...
}

Final ??? Much more cleaner ? -> must be split in different libs
 
Rabbit.Streaming.dll 
{
    Rabbit.Streaming
    Rabbit.Streaming.IO
    Rabbit.Streaming.IO.Containers { Container , AviContainer , etc that support bookmark }
    Rabbit.Streaming.IO.Compressions
    Rabbit.Streaming.IO.Compressions.Interop  => Add C++ COM Wrapper 
    Rabbit.Streaming.Logging
    Rabbit.Streaming.Logging.Appenders { RollingFileAppender , etc.. }
    Rabbit.Streaming.Devices
    Rabbit.Streaming.Net.Rtcp
    Rabbit.Streaming.Net.Rtcp.Clients
    Rabbit.Streaming.Net.Rtp
    Rabbit.Streaming.Net.Rtp.Clients
    Rabbit.Streaming.Net.Rtsp
    Rabbit.Streaming.Net.Rtsp.Clients
    Rabbit.Streaming.Net.Rtsp.Clients.Transports
    Rabbit.Streaming.Net.Rtsp.Servers
    Rabbit.Streaming.Net.Rtsp.Servers.Transports
    Rabbit.Streaming.Net.Sdp
    Rabbit.Streaming.Net.Sdp.Extensions
    Rabbit.Streaming.Net.Sdp.Serialization
    Rabbit.Streaming.Net.Sdp.Serialization.Formatters
    Rabbit.Streaming.Net.Sdp.Validations
    Rabbit.Streaming.Net.Sip
    Rabbit.Streaming.Net.Sip.Clients
    Rabbit.Streaming.Net.Sip.Clients.Transports
    Rabbit.Streaming.Net.Web.Hls
    Rabbit.Streaming.Net.Web.Hls.Clients
    Rabbit.Streaming.Net.Web.Rtc
    Rabbit.Streaming.Net.Web.Rtc.Clients
    Rabbit.Streaming.Net.Onvif
    Rabbit.Streaming.Net.Onvif.WS
    Rabbit.Streaming.Net.Onvif.WS.Ptz
    Rabbit.Streaming.Net.Onvif.WS.Io
    Rabbit.Streaming.Net.Onvif.WS.Media
    Rabbit.Streaming.Net.Onvif.WS.Device
    Rabbit.Streaming.Net.Onvif.WS.Events
    Rabbit.Streaming.Net.Onvif.Clients
    Rabbit.Streaming.Net.Psia
    Rabbit.Streaming.Net.Psia.Clients
    Rabbit.Streaming.Windows
    Rabbit.Streaming.Windows.Controls
    Rabbit.Streaming.Windows.Controls.Views
    Rabbit.Streaming.Windows.Controls.ViewsModels
}

Rabbit.Devices.dll
Rabbit.Devices.Cameras.dll
Rabbit.Devices.Cameras.Hik.dll
Rabbit.Devices.Cameras.Verint.dll
Rabbit.Devices.Cameras.Acti.dll
Rabbit.Devices.Cameras.IndigoVision.dll
Rabbit.Devices.Cameras.Bosch.dll
Rabbit.Devices.Cameras.Pelco.dll
Rabbit.Devices.Cameras.Axis.dll
Rabbit.Devices.Cameras.Teleste.dll
Rabbit.Devices.Cameras.UniView.dll
Rabbit.Devices.Cameras.Dahua.dll
Rabbit.Devices.Cameras.Survision.dll
Rabbit.Devices.Cameras.Onvif    .dll
Rabbit.Devices.Encoders.dll
Rabbit.Devices.Encoders.Verint.dll
Rabbit.Devices.Encoders.Nice.dll
Rabbit.Devices.Decoders.dll
Rabbit.Devices.Decoders.Verint.dll
Rabbit.Devices.Decoders.Planar.dll
Rabbit.Devices.Captures.dll
Rabbit.Devices.Captures.WebCam.dll
Rabbit.Devices.Captures.DirectShow.dll
Rabbit.Devices.Captures.Gutebruck.dll
Rabbit.Devices.Dvr.dll
Rabbit.Devices.Dvr.Bosch.dll
Rabbit.Devices.Dvr.Bosch.Divar.dll
Rabbit.Devices.Nvr.dll
Rabbit.Devices.Nvr.Dahua.dll
Rabbit.Devices.Nvr.Hik.dll
Rabbit.Devices.Intercoms.dll
Rabbit.Devices.Intercoms.Commend.dll
Rabbit.Devices.Intercoms.Commend.Icx.dll
Rabbit.Devices.Intercoms.Castel.dll
Rabbit.Devices.Intercoms.Castel.Maylis.dll

client.CommunicationStarted
client.CommunicationStopped
client.Connected
client.Disconnected
client.ConnectionFailed
client.AuthenticationFailed
client.DescribeError
client.SetupError
client.SetupError
client.Event
client.StreamingStarted
client.StreamingStopped
client.PacketReceived

Rabbit.Rtsp
Rabbit.Rtsp.Clients
Rabbit.Rtsp.Clients.Messaging
Rabbit.Rtsp.Clients.Messaging.Serialization
Rabbit.Rtsp.Clients.Remoting
Rabbit.Rtsp.Clients.Remoting.Invokers

Rabbit.Media.Rtsp
Rabbit.Media.Rtsp.Clients
Rabbit.Media.Rtsp.Sockets
Rabbit.Media.Rtsp.Remoting
Rabbit.Media.Rtsp.Remoting.Invokers
Rabbit.Media.Rtsp.Threading

public abstract class Client : IClient , IDispose
{
    public sealed class ClientRunner : IDispose
    {
        private readonly Client _client;

        public ClientRunner( Client client )
        {
            _client = client;
            _client.OnCommunicationStarted(...);
        }

        public void Run()
        {
            try
            {
                if ( ! _client.IsConnected )
                {
                    _client.DoConnect();
                    _client.DoDescribe();
                    _client.DoSetup();
                    _client.DoPlay();
                    _client.OnConnected(...);
                }
                else
                {
                    _client.Ping();
                }
            }
            catch(Exception ex)
            {
              if ( _client.IsConnected )
              {
                 _client.Close();
                 _client.OnClose();
              }
              _client.OnException( ex );
            }

            _client.DoIdle();
        }

        public void Dispose()
        {
            _client.OnCommunicationStopped(...);
        }
    }

    public abstract bool IsConnected {get; }
    public abstract bool IsCommunicationStarted { get; }
    public abstract void Start();
    public abstract void Stop();

    protected abstract TimeSpan GetIdleTimeout();
    protected abstract TimeSpan GetRetryTimeout();
    protected abstract bool DoWaitCancelation(TimeSpan span);
    protected abstract void DoShutdown();
    protected abstract void DoConnect();
    protected abstract void DoDisconnect();
    protected abstract void DoSetup();
    protected abstract void DoPlay();
    protected abstract void DoIdle();

    protected virtual void OnConnect() { }
    protected virtual void OnShutdown() { }
    protected virtual void OnDisconnect() { }
    protected virtual void OnSetup() { }
    protected virtual void OnTransportOpened() { }
    protected virtual void OnTransportClosed() { }
    protected virtual void OnPlay() { }
    protected virtual void OnTransportError() { }


    protected virtual void OnStarted(EventArgs e){ }
    protected virtual void OnStopped(EventArgs e) { }

}



